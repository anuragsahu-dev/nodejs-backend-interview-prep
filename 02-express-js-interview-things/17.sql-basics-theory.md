# SQL Basics

## What is SQL?

**SQL** (Structured Query Language) is used to store, read, update, and delete data inside relational databases. It allows you to manage data using tables, rows, columns, and relationships.

## What are SQL Databases?

SQL databases are **relational databases** that store data in tables (rows + columns) with relationships using **primary keys** and **foreign keys**.

**Examples:** PostgreSQL, MySQL, SQLite, SQL Server

**Use SQL when:** Data is structured, consistent, and needs relationships (e.g., users ↔ orders)

## CRUD Operations

### Table Setup

```sql
CREATE TABLE chai_store (
  id SERIAL PRIMARY KEY,
  chai_name VARCHAR(50),
  price DECIMAL(5,2),
  chai_type VARCHAR(50),
  available BOOLEAN
);
```

### 1. INSERT (Create)

```sql
-- Single row
INSERT INTO chai_store (chai_name, price, chai_type, available)
VALUES ('Masala Chai', 30.00, 'Spiced', TRUE);

-- Multiple rows
INSERT INTO chai_store (chai_name, price, chai_type, available)
VALUES
  ('Green Chai', 25.00, 'Herbal', TRUE),
  ('Black Chai', 20.00, 'Classic', TRUE);
```

### 2. SELECT (Read)

```sql
-- All columns, all rows
SELECT * FROM chai_store;

-- Specific columns
SELECT chai_name, price FROM chai_store;

-- Filter rows
SELECT * FROM chai_store WHERE available = TRUE;

-- Comparison & logical operators
SELECT * FROM chai_store WHERE price > 20 AND chai_type = 'Spiced';

-- Order results
SELECT * FROM chai_store ORDER BY price DESC;

-- Limit results
SELECT * FROM chai_store ORDER BY id LIMIT 5;

-- Distinct values
SELECT DISTINCT chai_type FROM chai_store;
```

### 3. UPDATE (Modify)

```sql
-- Update a single row
UPDATE chai_store
SET price = 32.00
WHERE id = 1;

-- Update multiple rows
UPDATE chai_store
SET available = FALSE
WHERE price > 35.00;

-- Return updated rows (PostgreSQL)
UPDATE chai_store
SET price = price * 1.05
WHERE available = TRUE
RETURNING id, price;
```

### 4. DELETE (Remove)

```sql
-- Delete matching rows
DELETE FROM chai_store WHERE id = 4;

-- Delete all rows (keep table structure)
TRUNCATE TABLE chai_store;

-- Remove entire table
DROP TABLE chai_store;
```

### 5. ALTER (Modify Table Structure)

```sql
-- Add column
ALTER TABLE chai_store ADD stock INT DEFAULT 0;

-- Change column type (PostgreSQL)
ALTER TABLE chai_store ALTER COLUMN price TYPE DECIMAL(10,2);

-- Drop column
ALTER TABLE chai_store DROP COLUMN stock;
```

## SQL Joins

Joins combine data from multiple tables based on related columns.

### Setup Tables

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50)
);

CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INT REFERENCES users(id),
  item VARCHAR(50),
  price DECIMAL(5,2)
);
```

### Types of Joins

#### INNER JOIN (Matching rows only)

```sql
SELECT users.name, orders.item, orders.price
FROM users
INNER JOIN orders ON users.id = orders.user_id;
```

Returns only users who have orders.

#### LEFT JOIN (All left rows + matches)

```sql
SELECT users.name, orders.item
FROM users
LEFT JOIN orders ON users.id = orders.user_id;
```

Returns all users, even if they have no orders (orders columns will be NULL).

#### RIGHT JOIN (All right rows + matches)

```sql
SELECT users.name, orders.item
FROM users
RIGHT JOIN orders ON users.id = orders.user_id;
```

Returns all orders, even if user doesn't exist.

#### FULL OUTER JOIN (All rows from both tables)

```sql
SELECT users.name, orders.item
FROM users
FULL OUTER JOIN orders ON users.id = orders.user_id;
```

Returns all users and all orders (PostgreSQL only; MySQL doesn't support this).

**Quick Summary:**

- **INNER** = Match only
- **LEFT** = Keep all left + matches
- **RIGHT** = Keep all right + matches
- **FULL** = Everything from both tables

## Aggregate Functions

Aggregate functions operate on multiple rows and return a single value.

### Common Aggregate Functions

```sql
-- COUNT: Number of rows
SELECT COUNT(*) FROM orders;
SELECT user_id, COUNT(*) FROM orders GROUP BY user_id;

-- SUM: Total of numeric column
SELECT SUM(price) FROM orders;
SELECT user_id, SUM(price) FROM orders GROUP BY user_id;

-- AVG: Average value
SELECT AVG(price) FROM orders;

-- MAX/MIN: Highest/Lowest value
SELECT MAX(price), MIN(price) FROM orders;
```

### GROUP BY and HAVING

**GROUP BY** groups rows with the same values. **HAVING** filters groups (like WHERE but for groups).

```sql
-- Total orders per user
SELECT user_id, COUNT(*) AS total_orders
FROM orders
GROUP BY user_id;

-- Only users with more than 1 order
SELECT user_id, COUNT(*) AS total_orders
FROM orders
GROUP BY user_id
HAVING COUNT(*) > 1;
```

**WHERE vs HAVING:**

- **WHERE** filters rows **before** grouping
- **HAVING** filters groups **after** aggregation

## Database Normalization

Normalization is the process of organizing data to reduce redundancy and improve data integrity.

### What is Data Redundancy?

**Data redundancy** means storing the same piece of information multiple times in different places. This leads to:

- **Wasted storage space** (same data repeated)
- **Update anomalies** (updating one copy but forgetting others leads to inconsistency)
- **Insertion anomalies** (can't add data without adding unrelated data)
- **Deletion anomalies** (deleting data removes other important information)

**Example of redundancy:**

| order_id | product_name | product_price | quantity |
| -------- | ------------ | ------------- | -------- |
| 101      | Masala Chai  | 30.00         | 2        |
| 102      | Masala Chai  | 30.00         | 1        |
| 103      | Masala Chai  | 30.00         | 3        |

Here, "Masala Chai" and its price are repeated in every order. If the price changes, you must update all rows.

### What is Data Integrity?

**Data integrity** means ensuring data is accurate, consistent, and reliable throughout its lifecycle. It includes:

- **Entity Integrity:** Each row must be unique (enforced by PRIMARY KEY)
- **Referential Integrity:** Relationships between tables must be valid (enforced by FOREIGN KEY)
- **Domain Integrity:** Data must be valid for its column type (e.g., age can't be negative)

**Example of integrity:**

```sql
-- Entity integrity: id is unique
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100)
);

-- Referential integrity: user_id must exist in users table
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INT REFERENCES users(id),  -- Foreign key ensures valid user
  amount DECIMAL(10,2)
);
```

**Why normalization helps:**

- Reduces redundancy → Less storage, easier updates
- Improves integrity → Data stays consistent and accurate

### 1NF (First Normal Form)

**Rule:** Each column must hold **atomic** (single) values. No repeating groups or arrays.

#### Problem: Unnormalized Table

```sql
-- BAD: Multiple phone numbers in one column
CREATE TABLE customers_bad (
  id INT PRIMARY KEY,
  name VARCHAR(100),
  phones VARCHAR(200)  -- "9991111,8882222" (comma-separated)
);
```

| id  | name | phones          |
| --- | ---- | --------------- |
| 1   | Ravi | 9991111,8882222 |
| 2   | Sita | 7773333         |

**Problem:** `phones` column contains multiple values (not atomic).

#### Solution: 1NF Compliant

```sql
CREATE TABLE customers (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100)
);

CREATE TABLE customer_phones (
  id SERIAL PRIMARY KEY,
  customer_id INT REFERENCES customers(id),
  phone VARCHAR(20)
);
```

**customers:**

| id  | name |
| --- | ---- |
| 1   | Ravi |
| 2   | Sita |

**customer_phones:**

| id  | customer_id | phone   |
| --- | ----------- | ------- |
| 1   | 1           | 9991111 |
| 2   | 1           | 8882222 |
| 3   | 2           | 7773333 |

**Result:** Each phone is now in its own row (atomic). ✅ 1NF satisfied.

### 2NF (Second Normal Form)

**Rule:** Must be in 1NF + **No partial dependency** (non-key columns must depend on the **entire** primary key, not just part of it).

This applies when you have a **composite primary key** (multiple columns).

#### Problem: Partial Dependency

```sql
-- BAD: Product details depend only on product_id, not the full composite key
CREATE TABLE order_items_bad (
  order_id INT,
  product_id INT,
  product_name VARCHAR(100),  -- Depends only on product_id
  product_price DECIMAL(8,2), -- Depends only on product_id
  quantity INT,
  PRIMARY KEY (order_id, product_id)
);
```

| order_id | product_id | product_name | product_price | quantity |
| -------- | ---------- | ------------ | ------------- | -------- |
| 101      | 1          | Masala Chai  | 30.00         | 2        |
| 101      | 2          | Green Chai   | 25.00         | 1        |
| 102      | 1          | Masala Chai  | 30.00         | 3        |

**Problem:** `product_name` and `product_price` depend only on `product_id` (part of the composite key), not on the full key `(order_id, product_id)`. This causes:

- **Data redundancy** (product details repeated)
- **Update anomalies** (changing product price requires updating multiple rows)

#### Solution: 2NF Compliant

```sql
CREATE TABLE products (
  product_id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  price DECIMAL(8,2)
);

CREATE TABLE order_items (
  order_id INT,
  product_id INT REFERENCES products(product_id),
  quantity INT,
  PRIMARY KEY (order_id, product_id)
);
```

**products:**

| product_id | name        | price |
| ---------- | ----------- | ----- |
| 1          | Masala Chai | 30.00 |
| 2          | Green Chai  | 25.00 |

**order_items:**

| order_id | product_id | quantity |
| -------- | ---------- | -------- |
| 101      | 1          | 2        |
| 101      | 2          | 1        |
| 102      | 1          | 3        |

**Result:** Product details are stored once in `products`. No partial dependency. ✅ 2NF satisfied.

### 3NF (Third Normal Form)

**Rule:** Must be in 2NF + **No transitive dependency** (non-key columns should not depend on other non-key columns).

#### Problem: Transitive Dependency

```sql
-- BAD: state depends on city (non-key → non-key dependency)
CREATE TABLE users_bad (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  city VARCHAR(100),
  state VARCHAR(100)  -- Depends on city, not directly on id
);
```

| id  | name | city      | state       |
| --- | ---- | --------- | ----------- |
| 1   | Ravi | Pune      | Maharashtra |
| 2   | Sita | Bangalore | Karnataka   |
| 3   | Amit | Pune      | Maharashtra |

**Problem:** `state` depends on `city` (non-key column), not directly on `id` (primary key). This causes:

- **Data redundancy** (Pune → Maharashtra repeated)
- **Update anomalies** (if city's state changes, must update all rows)
- **Insertion anomalies** (can't add a city without a user)

#### Solution: 3NF Compliant

```sql
CREATE TABLE locations (
  id SERIAL PRIMARY KEY,
  city VARCHAR(100),
  state VARCHAR(100)
);

CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100),
  location_id INT REFERENCES locations(id)
);
```

**locations:**

| id  | city      | state       |
| --- | --------- | ----------- |
| 1   | Pune      | Maharashtra |
| 2   | Bangalore | Karnataka   |

**users:**

| id  | name | location_id |
| --- | ---- | ----------- |
| 1   | Ravi | 1           |
| 2   | Sita | 2           |
| 3   | Amit | 1           |

**Result:** Each city-state pair is stored once. No transitive dependency. ✅ 3NF satisfied.

### Normalization Summary

| Normal Form | Rule                           | Key Point                                                                        |
| ----------- | ------------------------------ | -------------------------------------------------------------------------------- |
| **1NF**     | Atomic values only             | No arrays or comma-separated values in columns                                   |
| **2NF**     | 1NF + No partial dependency    | All non-key columns depend on the **entire** primary key                         |
| **3NF**     | 2NF + No transitive dependency | Non-key columns depend **only** on the primary key, not on other non-key columns |

## Interview Preparation Summary

### Essential Topics

1. **CRUD Operations:** SELECT (with WHERE, ORDER BY, LIMIT), INSERT, UPDATE, DELETE
2. **Joins:** INNER, LEFT, RIGHT, FULL OUTER (know the differences)
3. **Aggregates:** COUNT, SUM, AVG, MAX, MIN with GROUP BY and HAVING
4. **Normalization:** 1NF, 2NF, 3NF with clear examples

### Practical Tips

- **N+1 Problem:** Use JOIN or IN clause instead of multiple queries
- **Transactions:** Use for atomic operations (all or nothing)
- **TRUNCATE vs DROP:** TRUNCATE removes all rows but keeps table structure; DROP removes the entire table
